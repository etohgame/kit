"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6279],{98620:e=>{e.exports=JSON.parse('{"functions":[{"name":"log","desc":"Logs the provided `data` table into the output.","params":[{"name":"data","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":90,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"addItem","desc":"Adds the given item into the Scope, automatically cleaning it up when the\\nScope unloads.","params":[{"name":"self","desc":"","lua_type":"_TDefs.Scope"},{"name":"...","desc":"","lua_type":"T..."}],"returns":[{"desc":"","lua_type":"T...\\n"}],"function_type":"static","source":{"line":122,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"inherit","desc":"Creates a new child Scope within the current Scope. Used for client objects\\nthat have the capability of spawning other client objects, so cloned models\\ncan be cleaned up without the entire object\'s scope being removed.","params":[{"name":"data","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":153,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"removeItem","desc":"Removes the given item from the Scope. If `doNotCleanup` is set, the object\\nwill not be automatically destroyed along with this.","params":[{"name":"self","desc":"","lua_type":"_TDefs.Scope"},{"name":"item","desc":"","lua_type":"any"},{"name":"doNotCleanup","desc":"","lua_type":"boolean?"}],"returns":[],"function_type":"static","source":{"line":289,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"cleanup","desc":"Cleans up the Scope.\\nIf `defer` is set, the cleanup will be deferred rather than occuring immediately.\\nIf `destroy` is set, the Scope will be fully destroyed rather than only cleaning up.","params":[{"name":"defer","desc":"","lua_type":"boolean?"},{"name":"destroy","desc":"","lua_type":"boolean?"}],"returns":[],"function_type":"method","source":{"line":315,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"attach","desc":"Attaches the Scope to the given `instance`, cleaning up the Scope if\\nthe instance gets destroyed.","params":[{"name":"instance","desc":"","lua_type":"Instance"},{"name":"removeFromParentScope","desc":"","lua_type":"boolean?"}],"returns":[],"function_type":"method","source":{"line":340,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"spawn","desc":"Runs `task.spawn` with the given function and adds it to the Scope, cancelling\\nit if the Scope unloads while the task is running.","params":[{"name":"fn","desc":"","lua_type":"(T...) -> ...unknown"},{"name":"...","desc":"","lua_type":"T..."}],"returns":[],"function_type":"method","source":{"line":376,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"defer","desc":"Runs `task.defer` with the given function and adds it to the Scope, cancelling\\nit if the Scope unloads while the task is running.","params":[{"name":"fn","desc":"","lua_type":"(T...) -> ...unknown"},{"name":"...","desc":"","lua_type":"T..."}],"returns":[],"function_type":"method","source":{"line":395,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"delay","desc":"Runs `task.delay` with the given delay/function and adds it to the Scope, cancelling\\nit if the Scope unloads while the task is running.","params":[{"name":"seconds","desc":"","lua_type":"number"},{"name":"fn","desc":"","lua_type":"(T...) -> ...unknown"},{"name":"...","desc":"","lua_type":"T..."}],"returns":[],"function_type":"method","source":{"line":414,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}}],"properties":[],"types":[],"name":"Scope","desc":"Scopes are used for performance optimizations. Any client objects that get loaded\\nare placed into a Scope that will automatically clean up everything contained\\nwithin it when it unloads, in order to prevent lingering Instances and connections\\nfrom using unnecessary processing and memory.","realm":["Client"],"source":{"line":41,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}}')}}]);