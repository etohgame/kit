"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6279],{98620:e=>{e.exports=JSON.parse('{"functions":[{"name":"log","desc":"Logs the provided `data` table into the output.","params":[{"name":"data","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":157,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"add","desc":"Adds the given items into the Scope, automatically cleaning it up when the\\nScope unloads.\\nAll of the items that are passed in to this function will be returned right back.\\n\\n:::info\\nIt is important that you put all of your Instances and Connections in this \\nfunction to be cleaned up when the player leaves the tower. Any functions \\npassed in will run when it is time to clean up.\\n:::\\n\\n:::caution\\nThis function will throw an error if used during the scope\'s cleanup process.\\n:::","params":[{"name":"...","desc":"","lua_type":"T..."}],"returns":[{"desc":"","lua_type":"T...\\n"}],"function_type":"method","source":{"line":200,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"inherit","desc":"Creates a new child Scope within the current Scope. Used for client objects\\nthat have the capability of spawning other client objects, so cloned models\\ncan be cleaned up without the entire object\'s scope being removed.","params":[{"name":"data","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":229,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"remove","desc":"Removes the given item from the Scope. If `doNotCleanup` is set, the object\\nwill not be automatically destroyed along with this.","params":[{"name":"item","desc":"","lua_type":"any"},{"name":"doNotCleanup","desc":"","lua_type":"boolean?"}],"returns":[],"function_type":"method","source":{"line":363,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"cleanup","desc":"Cleans up the Scope.\\nIf `defer` is set, the cleanup will be deferred rather than occuring immediately.\\nIf `destroy` is set, the Scope will be fully destroyed rather than only cleaning up.","params":[{"name":"defer","desc":"","lua_type":"boolean?"},{"name":"destroy","desc":"","lua_type":"boolean?"}],"returns":[],"function_type":"method","source":{"line":388,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"attach","desc":"Attaches the Scope to the given `instance`, cleaning up the Scope if\\nthe instance gets destroyed.","params":[{"name":"instance","desc":"","lua_type":"Instance"},{"name":"removeFromParentScope","desc":"","lua_type":"boolean?"}],"returns":[],"function_type":"method","source":{"line":413,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"spawn","desc":"Runs `task.spawn` with the given function and adds it to the Scope, cancelling\\nit if the Scope unloads while the task is running.","params":[{"name":"fn","desc":"","lua_type":"(T...) -> ...unknown"},{"name":"...","desc":"","lua_type":"T..."}],"returns":[],"function_type":"method","source":{"line":449,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"defer","desc":"Runs `task.defer` with the given function and adds it to the Scope, cancelling\\nit if the Scope unloads while the task is running.","params":[{"name":"fn","desc":"","lua_type":"(T...) -> ...unknown"},{"name":"...","desc":"","lua_type":"T..."}],"returns":[],"function_type":"method","source":{"line":468,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"delay","desc":"Runs `task.delay` with the given delay/function and adds it to the Scope, cancelling\\nit if the Scope unloads while the task is running.","params":[{"name":"seconds","desc":"","lua_type":"number"},{"name":"fn","desc":"","lua_type":"(T...) -> ...unknown"},{"name":"...","desc":"","lua_type":"T..."}],"returns":[],"function_type":"method","source":{"line":487,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}}],"properties":[{"name":"instance","desc":"The scope\'s instance.","lua_type":"Instance?","source":{"line":91,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"scriptPath","desc":"The scope\'s script path.","lua_type":"string?","source":{"line":97,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"rootScope","desc":"The scope\'s root scope.","lua_type":"Scope","source":{"line":103,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"parentScope","desc":"The scope\'s parent scope.","lua_type":"Scope","source":{"line":109,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"id","desc":"The scope\'s ID.","lua_type":"string","source":{"line":115,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"tower","desc":"The tower\'s name.","lua_type":"string","source":{"line":121,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"clientObjects","desc":"The tower\'s client objects container.","lua_type":"Instance","source":{"line":127,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"shared","desc":"A shared table across every single scope inherited by the rootScope","lua_type":"{ [string]: any }","source":{"line":133,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"repository","desc":"A table of every single repository script that is currently loaded.","lua_type":"{ [string]: any }","source":{"line":139,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"active","desc":"A variable","lua_type":"boolean","source":{"line":145,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}},{"name":"activeScripts","desc":"All of the current scripts running","lua_type":"{ [string]: { [Instance]: boolean } }","source":{"line":151,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}}],"types":[],"name":"Scope","desc":"Scopes are used for performance optimizations. Any client objects that get loaded\\nare placed into a Scope that will automatically clean up everything contained\\nwithin it when it unloads, in order to prevent lingering Instances and connections\\nfrom using unnecessary processing and memory.","realm":["Client"],"source":{"line":41,"path":"mirror/Kit.Managers.ScopeConstructor.luau"}}')}}]);